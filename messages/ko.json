{
  "Main": {
    "hello": "안녕하세요,",
    "my_name": "이재훈",
    "my_job": "주니어 게임 개발자 입니다",
    "my_nickname": "Yesman",
    "my_virtual_job": "Epic Fight팀의 리드 개발자입니다",
    "pseudonyms": "가명 ➡️",
    "myself": "진명 ➡️",
    "about": "소개",
    "about1": "본인소개",
    "about2": "저는 대한민국 인천에 거주중인 초급 게임 개발자 입니다.",
    "about3": "저는 3D그래픽, 게임 개발과 관련된 수학, 그리고 물리 시뮬레이션에 관심이 많습니다. 저는 대학에서 컴퓨터공학을 전공했으며, 3차원 기하학과 벡터, OpenGL을 사용한 그래픽 파이프라인에 대해 흥미롭게 공부하였습니다. 제 일생의 목표는 제가 스스로 기획한 3D 액션 어드벤쳐 게임을 만드는 것입니다.",
    "about_yesman": "Yesman",
    "about_yesman1": "Yesman은 다양한 소셜 미디어를 통해 사람들과 소통할때 제가 사용하는 별칭입니다. 저는 2020년 8월부터 Epic Fight라 불리는 Minecraft 애드온 개발 프로젝트를 운영하고 있으며, 저의 게임 개발 스킬을 갈고닦을 수 있는 값진 경험이었습니다.",
    "projects": "프로젝트",
    "epicfight": "Epic Fight",
    "epicfight_subtitle": "The Minecraft Modding Project",
    "activities": "활동",
    "recent_videos": "최근 영상",
    "recent_postings": "최근 포스트"
  },
  "Project": {
    "epicfight": {
      "title": "Epic Fight - Minecraft 모딩 프로젝트",
      "subtitle1": "Epic Fight 란?",
      "content1": "Epic Fight는 Mojang Studios 샌드박스 게임 Minecraft의 애드온으로, 2020년부터 운영되어 현재 15,000명의 커뮤니티 회원수와 2천만 다운로드를 기록한 프로젝트로 성장하였습니다.",
      "subtitle2": "무엇이 바뀌나요?",
      "content2": "Epic Fight는 게임의 장르를 소울류 전투 게임으로 완전히 바꿉니다. 플레이어와 적들은 Skinned mesh, 그리고 Skeletal armature 등의 기법을 통해 기존 Minecraft보다 더욱 다채로운 움직임과 전투 시스템을 가지고 행동하며 적들과 싸우기 위해 플레이어는 더욱 세심한 컨트롤을 요구받게 됩니다.",
      "subtitle3": "개발 동기",
      "content3": "Minecraft를 플레이해본 적이 있다면 전투가 상당히 단조롭다 생각해본 적이 있을 것입니다. 적들을 조준하고 때리기만 하면 되니까요. 물론 Minecraft에서 전투는 큰 비중을 차지하지 않습니다. 하지만 저는 이 게임이 복쉘 그래픽을 기반으로 한 3D 액션 어드벤쳐물로 활용될 수 있다는 가능성을 보았습니다. 마인크래프트는 레벨 디자인 측면에서 아주 강력한 도구이기 때문에 많은 사람들이 던전, 아레나 등의 맵을 제작하여 공유하고 있습니다. 저는 이러한 훌륭한 맵들과 더불어 발달된 AI와 전투 시스템을 가진 몬스터들이 게임 내에 배치되어 플레이어의 모험 욕구를 자극하길 원했습니다.",
      "subtitle4": "구성원",
      "developer": "개발자",
      "manager": "프로젝트 매니저",
      "subtitle5": "관련 링크",
      "distribute": "모드 파일 유통",
      "source_code": "소스코드",
      "subtitle6": "Devlog",
      "post1": "Skinned mesh 와 애니메이션",
      "post2": "OBB를 사용한 충돌 감지",
      "post3": "Bezier Curve를 이용해 궤적 그리기",
      "post4": "절차적 애니메이션",
      "post5": "천 시뮬레이션",
      "animation": {
        "title": "Skinned Mesh 와 Skeletal Animations",
        "date": "2025.08",
        "synopsis": "개요",
        "synopsis_content": "Skinned mesh 와 Skeletal animation은 컴퓨터 그래픽에서 모델을 실시간으로 변형하기 위해 가장 널리 사용되는 기법입니다. 모델은 크게 Mesh 와 Armature 부분으로 나뉘는데, Mesh가 모델의 전체적인 형태를 정의한다면 Armature는 모델이 어떻게 변형될수 있는지를 정의합니다. Armature는 여러개의 Joint들이 트리 구조로 이루어진 모습을 하고 있으며 Mesh의 각각의 정점들은 Joint들의 움직임에 영향을 받아서 함께 움직입니다.",
        "challenge": "과제",
        "challenge_content": "Minecraft는 Skinned Mesh를 지원하지 않습니다. 또한 모든 애니메이션이 코드로 구현되어 있어서 움직임이 상당히 딱딱하며, 단조롭습니다. 사실 이것은 게임이 추구하는 복쉘 그래픽의 분위기를 내기 위한 장치이지만, 저는 게임의 분위기를 크게 해지지 않는 한 플레이어와 몬스터에게 자연스러운 움직임을 주는 것이 중요하다 생각했습니다. 그리고 애니메이션 코드를 외부의 리소스 형태로 분리할 수 있다면 생산성의 향상에도 크게 도움이 될 것이라 생각했습니다.",
        "solution": "문제 해결",
        "solution_content": "저는 3D모델링과 애니메이션 제작에 관심이 많았기 때문에 무료 3D 그래픽 생성 툴인 Blender의 사용법에 대해 어느 정도 숙지하고 있는 상태였습니다. 제가 설계한 시스템은, 모든 애니메이션 파일을 json 형식으로 저장하고 게임이 로드될 때 한꺼번에 읽는 것이었습니다. 이는 애니메이션을 하드코딩하는 것보다 효율성과 생산성 향상에 도움이 되었습니다. 이를 위해서 Blender에서 json형식으로 애니메이션을 익스포트 하기 위한 모듈과 게임 안에서 애니메이션 리소스를 읽기 위한 importer를 구현해야 했습니다.",
        "implementation": "구현",
        "implementation_content1": "Blender는 Python 언어로 작성되었습니다. 저는 다음과 같은 익스포트 모듈을 만들었습니다.",
        "implementation_content2": "이 코드는 Mesh, Armature 그리고 애니메이션을 JSON 파일로 내보냅니다. JSON 파일은 그 문법이 매우 직관적이고 간단하여 리소스 최적화에 용이합니다. 또한 애니메이션 제작이 코드와 숫자에 의존하지 않고, 3D틀 안에서 눈으로 보며 직접 이루어지다 보니 훨씬 편리하였습니다.",
        "implementation_content3": "그 다음, 게임 내부에서 리소스 파일을 읽는 모듈을 작성하였습니다.",
        "implementation_content4": "이 프로그램은 미리 지정된 위치에서 에셋을 읽어옵니다. Skinned Mesh에 필요한 정점의 위치, 법선 벡터, 텍스처 좌표, 그리고 리깅 데이터를 읽어오며 Armature의 경우엔 트리 형태로 표현된 Joint들을 읽어옵니다. 마지막으로 애니메이션에 필요한 키프레임과 4x4 변환 행렬을 읽어옵니다.",
        "result": "결과",
        "references": "참조"
      },
      "obb": {
        "title": "OBB(Oridented Bounding Box)를 통한 충돌 검사",
        "date": "2025.08",
        "synopsis": "개요",
        "synopsis_content": "두 오브젝트가 충돌했는지 판별하는 방법은 여러가지가 있습니다. OBB는 충돌 결과의 정확성, 그리고 성능 면에서 가장 무난한 방법입니다. 충돌체의 모양은 회전 가능한 직육면체 (2차원에서는 직사각형)을 기반으로 동작합니다.",
        "optimization": "최적화",
        "optimization_content1": "OBB를 구현하기 전에 하나의 고려사항이 있었습니다. Minecraft는 충돌 검사를 위해서 오직 AABB(Axis-Aligned Bounding Box) 만을 사용합니다. AABB는 OBB에 비해 충돌 검사 과정이 훨씬 좋은 성능을 가지고 있습니다. 그래서 OBB를 통해 모든 오브젝트를 검사하기 전에 AABB를 통하여",
        "optimization_content2": "충돌 가능성이 있는 오브젝트만",
        "optimization_content3": "을 필터링 한 후 남은 오브젝트들에 대해 OBB 충돌 검사를 시행하는 방법을 고안하였습니다.",
        "implementation": "구현",
        "implementation_content1": "OBB는 3개의 벡터를 통하여 충돌을 감지합니다. 첫 번째 OBB의 중점에서 에서 두 번째 OBB의 중점으로 향하는 벡터, 그리고 각각의 OBB의 중점에서 모서리로 향한 벡터입니다. 이 벡터들은 ",
        "implementation_content2": "분리축",
        "implementation_content3": "이라 불리는 벡터에 투영됩니다. 아래의 그림은 OBB 충돌이 어떻게 작동하는지 이해를 도울 것입니다.",
        "implementation_content4": "OBB 알고리즘의 최종 목표는 두 개 모서리 -> 중점 벡터 의 투영된 벡터(PA and PB) 의 길이의 합이 중점 -> 중점 벡터의 투영된 값보다 작은 분리축을 찾는 것입니다. 해당 조건을 만족하는 분리축을 찾았다면, 두 충돌체는 충돌하지 않는 것입니다. 분리축 후보는 각각의 OBB 평면의 법선 벡터들입니다.",
        "result": "결과",
        "result_content": "Entity와 충돌할 때 OBB가 붉게 변합니다",
        "references": "참조"
      },
      "bezier": {
        "title": "Bezier Curve를 이용해 궤적 그리기",
        "date": "2025.08",
        "synopsis": "개요",
        "synopsis_content": "궤적 효과는 게임을 더욱 다채롭게 만듭니다. 일반적으로 화살, 총알, 휘두르는 칼 등 게임 내에서 빠르게 움직이는 물체들과 함께 쓰이며 잔상 효과를 강화합니다. 여기서 잔상 효과란, 인간의 뇌에 피사체가 남아있어서 마치 그 곳에 있는 착각이 드는 일종의 착시 현상입니다. 잔상 효과를 컴퓨터 그래픽에서 적절히 사용하면 사용자는 빠르게 움직이는 물체의 움직임을 정확히 인식할수 있게 됩니다.",
        "bezier": "Bezier Curve",
        "bezier_content1": "",
        "bezier_content2": "베지어 커브",
        "bezier_content3": "는 프랑스의 수학자",
        "bezier_content4": "피에르 베지에 (Pierre Bézier, 1910 ~ 1999)",
        "bezier_content5": "에 의해 고안된 곡선을 그리는 수학적 기법이며, 다차 함수의 특성을 이용합니다.",
        "bezier_content6": "위 그림은 베지어 커브가 동작하는 방식을 설명합니다. 베지어 커브는 제어점을 사용하여 그 사이를 보간하는 함수를 구합니다. 필자가 필요로 했던 베지어 커브는 모든 제어점을 지나가면서 미분값이 일정한 조건을 만족해야 했는데, 이는 플레이어의 애니메이션이 생성하는 각각의 제어점을 통과해야 잔상 효과의 의의를 살릴 수 있었기 때문입니다. 몇번의 검색 결과 운좋게도 요구조건을 충족하는 곡선을 생성하는",
        "bezier_content7": "스플라인 베지어 커브",
        "bezier_content8": "라는 기법을 찾아냈습니다. 자세한 수학적 원리는 이 글에서 다루지 않으며, 참조란에 출저를 적어 놓겠습니다.",
        "implementation": "구현",
        "implementation_content1": "먼저 제어점을 생성하기 위해 각각의 무기에 대한 시작점과 종료점을 정의했습니다. 아래 코드 블럭은 리소스 파일의 일부입니다.",
        "implementation_content2": "다음 목표는 현재 플레이어의 애니메이션을 기반으로 제어점을 생성하는 것입니다. 이때",
        "implementation_content3": "Skinned mesh 와 애니메이션",
        "implementation_content4": "에서 다뤘던 Joint가 사용됩니다. 애니메이션은 4x4 변환 행렬으로 저장되므로, 무기의 시작지점과 끝 지점 벡터에 곱하면 특정 포즈에서 제어점의 위치를 구하였습니다. 한 번의 프레임 타임에 총 3개의 제어점을 생성하였는데 이들은 이전 프레임 타임에 저장된 포즈의 제어점과 현재 포즈에서 계산된 제어점, 그리고 이전 포즈와 현재 포즈를 1:1 보간한 포즈의 제어점으로 구성되어 있습니다.",
        "implementation_content5": "마지막으로, 주어진 컨트롤 포인트를 바탕으로 베지어 커브 함수에 의해 보간된 점들을 생성합니다.",
        "result": "결과",
        "references": "참조"
      },
      "procedural": {
        "title": "절차적 애니메이션",
        "date": "2025.08",
        "synopsis": "개요",
        "synopsis_content": "애니메이션을 주로 리소스 형태로 존재하며 정적입니다. 하지만 개발자들은 인게임 상황을 반영할 수 있는 대화형 애니메이션에 대한 필요성을 느꼈습니다. 절차적 애니메이션은 이런 요구를 반영한 애니메이션 기법 중 하나입니다. 이런 종류의 애니메이션은 인게임 오브젝트들에 의해 포즈가 변형될 수 있습니다.",
        "problem": "정적인 애니메이션의 문제점",
        "problem_content": "엔터티가 충분히 크다면, 모델의 지면과 맞닿는 부분이 공중에 뜬 것 같은 문제점에 부딫히게 될 것입니다. 이것은 애니메이션이 정적이고 게임 안의 상황을 고려할 수 없기 때문입니다.",
        "ik": "역기구학",
        "ik_content1": "해결책은 명확합니다. 애니메이션이 지형을 감지할 수 있도록 하는 것입니다. 리소스에 저장된 기본 포즈를 순차적으로 계산하는 대신에 모델의 발과 맞닿은 지면 부분의 높이를 계산하고, 그 결과를 역순으로 계산하면 문제가 해결될 것입니다. 역기구학은 이런 상황을 해결할 수 있도록 설계되었습니다. 기존의 최상위 Joint에서 시작하여 말단까지 애니메이션 포즈를 계산해나가는 방법은 정확히 말하면 \"순기구학\" 에 해당합니다. 이름에서 알 수 있듯이 역기구학은 이러한 과정이 반대로 진행됩니다. 말단의(또는 최상위가 아닌) Joint의 위치 정보를 미리 지정하면, 최상위 노드까지 올라가면서 포즈를 계산하는 것입니다.",
        "ik_content2": "그렇다면 어떻게 조정된 포즈를 계산할 수 있을까요? 필자가 선택한 방법은",
        "ik_content3": "FABRIK",
        "ik_content4": "(Forward and Backward Reaching Inverse Kinematics)",
        "ik_content5": ", 역기구학의 방법론 중 하나입니다.",
        "ik_content6": "위 그림은 FABRIK이 동작하는 과정을 간단하게 보여줍니다. 그림에서 초록색 원은 우리가 재설정 하고자 하는 지형의 높이를 반영한 위치이고, 1, 2, 3, 4번 원들은 Joint의 끝 지점입니다.",
        "ik_content7": "이 알고리즘은 말단 Joint의 끝 지점 (점1)을 목표 지점 (초록색 원)에 올려놓는 것으로 시작합니다. 이 과정에서 Joint의 길이는 변하게 되는데, 이것을 보정하기 위해 Joint의 시작 지점 (점2)을 끝 지점 (점1)로 끌어옵니다. 이 과정을 점4번까지 반복한다면 말단 Joint가 우리가 원하는 위치에 놓이게 되고, 모든 Joint들이 원래의 길이를 유지한 상태가 됩니다.",
        "ik_content8": "하지만 결과를 유심히 본다면, 최상위 Joint (점3과 점4)가 시작 지점 (파란색 원)에서 조금 어긋난 것을 볼 수 있습니다. 이를 해결하기 위해서 다시 1>2>3>4 순서로 이루어졌던 진행 과정을 다시 4>3>2>1 순으로 진행하면 됩니다. 흥미로운 점은, 이 과정을 반복한다면 두 끝 지점 (점1과 점4) 에 대한 오차를 점점 줄여나갈 수 있다는 것입니다.",
        "ik_content9": "이를 통해 알 수 있는 알고리즘의 특성은 정확도와 성능 사이의 타협점이 반복 횟수, 즉",
        "ik_content10": "앞과 뒤",
        "ik_content11": "로 움직이는 횟수에 결정된다는 것입니다.",
        "implementation": "구현",
        "implementation_content1": "역기구학만으로 이루어진 애니메이션 보단, 필자는 원래의 애니메이션과 역기구학이 적절하게 섞인 시스템을 설계했습니다. 우선 애니메이션 키프레임마다 발바닥이 땅을 밟고 있는지에 대한 여부를 알 수 있는 변수를 설정하였습니다. 그리고 \"땅에 닿아있음\"으로 설정된 키프레임만 지형의 높이를 구하여 애니메이션을 변형하도록 하였습니다.",
        "implementation_content2": "이것은 \"발의 최종 목적지\"에 대한 애니메이션을 생성하도록 합니다. 그 다음, FABRIK 알고리즘을 통해 재계산된 포즈를 적용하도록 하였습니다.",
        "result": "결과",
        "references": "참조"
      },
      "cloth": {
        "title": "천 시뮬레이션",
        "date": "2025.08",
        "synopsis": "개요",
        "synopsis_content": "옷감은 컴퓨터 그래픽으로 표현하기 가장 어려운 물체 중 하나입니다. 현실 세계에서 옷감은 단단한 물체와 다르게 그 모양이 변형되기 매우 쉽습니다. 물체를 렌더링하는 고전적인 방법은 이 특성과 매우 반대됩니다. 모델은 게임이 로딩될때 리소스에서 읽어와 메모리에 로드되고, 그 데이터는 변경되지 않습니다. 이럴 때 물체에 실시간으로 적용되는 시뮬레이션을 통해 모델을 변형하는 방법을 고려해 볼 수 있습니다.",
        "terminology": "시뮬레이션이란?",
        "terminology_content0": "컴퓨터 과학에서, ",
        "terminology_content1": "시뮬레이션",
        "terminology_content2": "은 다음과 같이 정의됩니다. ",
        "terminology_content3": "\"수학적 모델이나 가설을 프로그램을 통해 구동한다\".",
        "terminology_content4": "시뮬레이션은 초기 상태에서 시작하여, 시간이 지날수록 그 상태가 변화합니다. 떨어지는 공을 예로 들자면, 우리는 중력가속도와 물체의 질량을 통해 물체의 위치에 대한 수학적 방정식을 세울 수 있고, 시간의 변화 값에 결과를 곱하면 n초후의 지면으로 향한 공의 움직임을 구할 수 있습니다.",
        "terminology_content5": "해당 물체는 \"시뮬레이션 되고 있다\"고 볼 수 있습니다. 핵심은, 사용자가 수학 공식과 시간 변화량을 컴퓨터에 입력하면 시뮬레이션이 구동되는 동안 모든 것은 컴퓨터의 계산에 의해 결정된다는 것입니다.",
        "description": "천의 움직임에 대한 방정식: 스프링-매스 시스템",
        "description_content": "천을 구성하는 실들을 서로 밀고 당기는 스프링으로 본다면 이에 대한 방정식을 세워볼 수 있습니다. 이에 대해 가장 유명한 접근은 스프링-매스 시스템, 용수철이 늘어남과 줄에듦에 따라 가해지는 힘의 변화에 대해 설명하는 수학적 모델입니다.",
        "pbd": "PBD: 시뮬레이션 폭발 막기",
        "pbd_content1": "스프링-매스 시스템을 이용하여 시뮬레이션을 할 때 한가지 문제점이 있습니다. 하나의 옷감은 서로 연결된 수 많은 파티클들로 이루어져 있으며 서로 힘이 전이됩니다. 이러한 구조는 전이되는 힘이 기하급수적으로 상승할 수 있는 가능성이 있으며 이는 시뮬레이션 되고 있는 값이 비정상적으로 설정되고 스스로 회복할 수 없는 지경에 이르게 됩니다.",
        "pbd_content2": "이러한 문제를 해결하기 위해,",
        "pbd_content3": "PBD",
        "pbd_content4": "(Position Based Dynamics)",
        "pbd_content5": "라는 새로운 방법론이 등장하였습니다. 스프링에 대한 힘을 계산하는 대신, 스프링의 초기 길이와 현재 길이를 비교하여 다음 파티클의 위치를 계산하는 것입니다.",
        "pbd_content6": "이러한 일련의 프로세스를 \"제약을 추가한다\" 라고 명명합니다. PBD에는 다양한 종류의 제약이 있는데, Stretching 제약은 두 파티클을 연결한 스프링의 길이를 유지하기 위해 사용되며, Shearing 제약은 모델을 이루는 다각형의 모양을 유지하기 위해, Bending 제약은 두 인접한 다각형(주로 삼각형으로 나뉨) 이 이루는 각도를 유지하기 위해 사용됩니다.",
        "implementation": "구현",
        "implementation_content1": "천 시뮬레이션을 인게임에 이식하는 것은 꽤나 도전적인 과제였습니다. 먼저 시뮬레이션되는 물체는 플레이어를 따라다녀야 하므로 각각의 파티클에 시뮬레이션에 의해 영향받는 정도를 결정하는 변수를 설정하였습니다. 그리하여 시뮬레이션에 의해 조종되지 않는 파티클들은 플레이어의 위치를 따라다니도록 하였습니다.",
        "implementation_content2": "필자가 주목한 또다른 문제점은 시뮬레이션 되는 물체가 프레임이 낮을수록 늘어지는 문제였습니다. 프레임 실행 시간이 곧 시간의 변화이므로 시뮬레이션의 정확도가 떨어지기 때문입니다. 그래서 Stretching 제약에서 약간 수정된 제약을 추가하였습니다. 두 개의 파티클을 동시에 당기는 대신, 하나의 파티클을 기준으로 삼고 다른 파티클의 위치만을 변경하는 것입니다. 필자는 이 제약을 Shape 제약, 즉 천의 모양을 유지하는 제약이라 이름 붙였습니다.",
        "result": "결과",
        "references": "참조"
      }
    }
  }
}