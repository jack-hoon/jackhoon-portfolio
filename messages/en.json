{
  "Main": {
    "hello": "Hi! I'm",
    "my_name": "Lee Jae Hoon",
    "my_job": "A junior game developer",
    "my_nickname": "Yesman",
    "my_virtual_job": "A lead developer of Epic Fight team",
    "pseudonyms": "Pseudonyms ➡️",
    "myself": "myself ➡️",
    "about": "About",
    "about1": "Who am I?",
    "about2": "I'm a junior game developer from Incheon, South Korea.",
    "about3": "I am interested in 3D Graphics, Mathematics for Game Development, and Physics Simulation. I majored in computer science in university. While I was in there, I learned mathematics for three-dimensional geometries and vector, and general graphic pipelines using OpenGL. My lifelong goal is to create a 3D action adventure game designed and programmed by me.",
    "about_yesman": "Who is Yesman?",
    "about_yesman1": "Yesman is my nickname used in various social media platforms to communicate with people in online. I've run a project for Minecraft addon called Epic Fight since August 2020, which has been a greatly valuable experience in polishing my skills.",
    "projects": "Projects",
    "epicfight": "Epic Fight",
    "epicfight_subtitle": "The Minecraft Modding Project",
    "activities": "Activities",
    "recent_videos": "My recent videos",
    "recent_postings": "My recent postings"
  },
  "Project": {
    "epicfight": {
      "title": "Epic Fight - Minecraft Modding Project",
      "subtitle1": "What is Epic Fight?",
      "content1": "Epic Fight is an addon of MinecraftㅡA sandbox game from Mojang Studios. The project has run since August. 2020 and has grown to over 15,000 community members and 20 million downloads.",
      "subtitle2": "What does the addon do?",
      "content2": "It completely turns the game into the soul-like genre with more reinforced behaviors for player and enemies. Animations based on skeletal armatures and skinned mesh will make the players' and enemies' movement colorful, and the unique battle system will require your precise mechanics to defeat your enemies.",
      "subtitle3": "Why did you create the addon?",
      "content3": "If you have ever played Minecraft, you might feel the battle quite monotonous. The only thing you have to do is aiming to an enemy, then hit it. Even tho the combat is not the main content of Minecraft, I saw the possibility that the game could be used as 3D action adventure, with the voxel graphics. Since Minecraft provides useful ways for level design such as creating structures and dungeons, I hoped we could also have well-designed enemies that enhance the player's desire to explore the world.",
      "subtitle4": "Team members",
      "developer": "Developer",
      "manager": "Manager",
      "subtitle5": "Portals",
      "distribute": "Mod file distribute",
      "source_code": "Source code",
      "subtitle6": "Devlog",
      "post1": "Skinned mesh and animation",
      "post2": "Collision detection with OBB",
      "post3": "Trail particle using Bezier Curve",
      "post4": "Procedural animation",
      "post5": "Cloth simulation",
      "animation": {
        "title": "Skinned Mesh and Skeletal Animations",
        "date": "August 2025",
        "synopsis": "Synopsis",
        "synopsis_content": "The skinned mesh and skeletal animation are common techniques for deforming a model in real-time. The model is split into two parts: Mesh and Armature. Mesh defines the shape of the model, and Armature defines how the model can move. Armature consists of multiple Joints in a tree hierarchy. Each vertex has information about which joint and how much the vertex will be affected by the transform of Joints in Armature.",
        "challenge": "Challenge",
        "challenge_content": "The main issue was that Minecraft didn't use the skinned mesh system at all. The game's code-controlled movements made all movements robotic and too simple. This is what they seek to keep the mood of the voxel graphic game. Nevertheless, I decided to make skinned mesh into the game because I thought it is still a great deal if we could have more natural movement for players and mobs, as long as it doesn't hurt the overall feeling of the game, and separaing animation code to external resource files would reinforce the productivity noticeably.",
        "solution": "Solution",
        "solution_content": "I was interested in 3D modeling and animating. Thus, I had some knowledge about how to use Blender, a 3D graphics software available for free. I imagined a system that I could save all animation data as resource files and read all animation resources at runtime instead of hard-coding all animations in the development environment. To this end, I organized what I needed: An exporter module for Blender, an animation reader.",
        "implementation": "Implementation",
        "implementation_content1": "Blender is written by Python, so I created this exporter module.",
        "implementation_content2": "The code exports mesh, armature, and animation in JSON format. As a result, I was able to save my animations into the JSON assets. It was more convenient to maintain them since I could modify the animations depending on my aesthetic sense, not numbers and code. Below is .json file created by the exporter.",
        "implementation_content3": "Then I made the asset reader inside my mod.",
        "implementation_content4": "It reads asset files from a pre-defined location. For skinned meshes, it reads each vertex's position, normal, texture, and skinning data. For armatures, it reads joints expressed as a tree structure in JSON. Lastly, for animations, it reads keyframes and joint transforms expressed as a Matrix.",
        "result": "Result",
        "references": "References"
      },
      "obb": {
        "title": "Collision detection with OBB(Oridented Bounding Box)",
        "date": "August 2025",
        "synopsis": "Synopsis",
        "synopsis_content": "There are various mathematical ways to check whether two objects have collided. OBB is a modest way to detect collision in terms of both accuracy and performance. It's based on a cuboid (or a rectangle if it's 2-dimensional space) that can rotate on any axis.",
        "optimization": "Optimization",
        "optimization_content1": "There was one more consideration before I implemented OBB. Minecraft uses AABB(Axis-Aligned Bounding Box) to detect collision. AABB is a much cheaper method to detect collision compared to OBB. So if I check all objects with OBB, that would be a waste of computing power. The alternative way I came up with is to detect all objects that",
        "optimization_content2": "have a chance to collide",
        "optimization_content3": "with the OBB first, then check the filtered objects by the OBB.",
        "implementation": "Implementation",
        "implementation_content1": "OBB detects collision by three vectors. A vector from the center of the first OBB to the second OBB, and each vector from the center to a vertex of the OBBs. All these vectors are projected to a vector called",
        "implementation_content2": "Separated Axis.",
        "implementation_content3": "Below picture describes how OBB works.",
        "implementation_content4": "The goal of the OBB algorithm is to find a separating axis where the distance sum of the two projected vectors(PA and PB) is less than the projected vector from the center of OBB A to OBB B. If you find the separating axis that meets the condition, the OBBs are not colliding. The separating axis is selected among the normal vectors of the OBB's each plane.",
        "result": "Result",
        "result_content": "The OBB collider turns red when it hits the entity",
        "references": "References"
      },
      "bezier": {
        "title": "Trail effect with Bezier curve",
        "date": "August 2025",
        "synopsis": "Synopsis",
        "synopsis_content": "The trail effect makes games much more colorful. It is commonly used with objects with fast movement, like arrows, bullets, and swords in a human's hand. It reinforces the afterimage effect, a phenomenon that the human brain recognizes a prior image after it has been removed, allowing players to trace the motion of an moving object.",
        "bezier": "Bezier Curve",
        "bezier_content1": "The key principle of the trail effect is the",
        "bezier_content2": "Bezier curve",
        "bezier_content3": ", which is invented by",
        "bezier_content4": "Pierre Bézier(1910 ~ 1999)",
        "bezier_content5": ". It uses the curve created by the square function.",
        "bezier_content6": "As seen on the picture above, the points decide the shape of the curve. However, the type of Bezier curve we need is something special. Since we want to express the afterimage of a moving object, the curve needs to pass through control points created by the object at a specific time. Thankfully, I found an article that explains the curve what I exactly wanted: The",
        "bezier_content7": "Spline Bezier curve",
        "bezier_content8": ". I won't handle the mathematical principle in this post, but I'll leave the reference at the end of the post.",
        "implementation": "Implementation",
        "implementation_content1": "First, to create the control points of the trail effect, I defined the edge and root points of the blade part of each weapon as resources.",
        "implementation_content2": "The next step is creating control points based on the player's current animation. I used the Joint transform, introduced on",
        "implementation_content3": "Skinned mesh and Armature",
        "implementation_content4": ". The animation transform data is saved as 4x4 matrix, so multiplying the matrix by the weapon's root and edge location vector will return the location of each point in a specific pose. There are three control points created in a tick. one for the previous location, one for the current location, and one for the middle pose between the previous and current pose.",
        "implementation_content5": "Lastly, it creates the interpolated points created by the given control points.",
        "result": "Result",
        "references": "References"
      },
      "procedural": {
        "title": "Procedural Animation",
        "date": "August 2025",
        "synopsis": "Synopsis",
        "synopsis_content": "Animations usually exist as a resource, and are static. But game developers had felt the necessity of interactive animations that reflect the other objects in the game. Procedural animation is one of these technique. It decides the object's pose dynamically counting the environment nearby the object.",
        "problem": "The problem of static animations",
        "problem_content": "If your entity is big enough, you'll encounter the issue where the sustaining part of your model looks like it's floating in the air. This is because the animations are made in external program, where you can't consider the environment in game.",
        "ik": "Inversed Kinematics",
        "ik_content1": "The solution seems obvious: Make the animations detect terrain. So instead of resulting in the default pose, it calculates the ground height of the foot's location. Inverse kinematics is the best solution in this case. Technically, the way we decide the pose of entities is Forward kinematics, multiplying pose transform from the root to each terminal joints. As the name implies, Inverse kinematics determines the pose from the terminal(or a bone that is not a root). We can give the ground location we calculated before, then set the location of the foot to that.",
        "ik_content2": "Then how do we determine the corrected pose? The solution is",
        "ik_content3": "FABRIK",
        "ik_content4": "(Forward and Backward Reaching Inverse Kinematics)",
        "ik_content5": ", one of the methodologies of Inverse kinematics.",
        "ik_content6": "The picture shows how FABRIK works briefly. The green circle on the illustration is equal to the ground location we supposed above. And the points numbered as 1, 2, 3, and 4 are the endpoints of joints.",
        "ik_content7": "The algorithm starts by putting the endpoint of the terminal joint (point 1) at the destination point. It creates the difference in the length of the joint. To keep the original length, it pulls the starting point (point 2) over the endpoint (point 1). Repeating this process until the root joint will make a pose that that terminal bone's endpoint is located in our desired location, and all joints are keeping its original length.",
        "ik_content8": "But if you take a look at the result carefully, the root joint (from point 3 to 4) is slightly off a bit from the original location (the blue circle). We can solve this issue by repeating the algorithm starting from the root joint. The interesting point is that the error of each endpoint (point 1 and 4) after finishing the iteration will decrease as we repeat the process more and more.",
        "ik_content9": "Now we can realize the feature of this algorithm—The compromise between accuracy and performance is determined by the number of the loops that correcting joints",
        "ik_content10": "forward and backward",
        "ik_content11": ". (The name of this algorithm!)",
        "implementation": "Implementation",
        "implementation_content1": "I designed a system that mixes the original animation and inverse kinematics properly. First, I defined a variable for each keyframe that judges if it touches a ground or not. Then checks the ground height only for keyframes checked as touches ground.",
        "implementation_content2": "This will create the dynamic animation for destination points. Then, I ran FABRIK algorithm for each leg joints.",
        "result": "Result",
        "references": "References"
      },
      "cloth": {
        "title": "Cloth Simulation",
        "date": "August 2025",
        "synopsis": "Synopsis",
        "synopsis_content": "Cloth is one of the hardest materials to express in computer graphics. In the real world, the shape is highly susceptible to deformation, unlike rigid objects. The classic way to render objects in a computer is very against this propety beacuse it usually bakes the models when game is loaded and the data is never changed in runtime. In a given situation, we can consider the cloth simulation applied to the objects in the game.",
        "terminology": "What is simulation?",
        "terminology_content0": "",
        "terminology_content1": "Simulation",
        "terminology_content2": " in computer science is defined as this:",
        "terminology_content3": "Running a hypothesis based on mathematical model.",
        "terminology_content4": "Simulation starts with a initial state. And the state changes as the time elapses. Let's suppose a falling ball. We can design a mathematical model with gravitational acceleration and mass of the object, then multiplying the time delta will result in the movement amount of the ball toward the ground at n seconds later.",
        "terminology_content5": "We can say the location of the object is being simulated. We give the formula and time rate, then the computer will calculate everything else.",
        "description": "Equation for the movement of a cloth: Spring-Mass system",
        "description_content": "We can consider each cloth string as a spring that pulls the others. The most famous approach is Spring-Mass system, a mathematical model that describes the force of a spring with a mass attached to it.",
        "pbd": "PBD: Prevent the simulation explode",
        "pbd_content1": "There is a problem with simulating a cloth using a spring-mass system. The cloth consists of neumerous particles that are connected each other, and propagate the force to other connections, there is a possibility that the force grows exponentially. This will make the simulated values abnormal, and unrecoverable by itself.",
        "pbd_content2": "A new simulation method called",
        "pbd_content3": "PBD",
        "pbd_content4": "(Position Based Dynamics)",
        "pbd_content5": "has been introduced to solve this problem. Instead of calculating forces, it compares the initial length and current length of the springs and calculates the next position by the length difference.",
        "pbd_content6": "We call the series of this process as \"adding a constraint\" to the model. There could be various constraints, Stretching constraints to keep the the original length of two particles, Shearing constraints to keep the shape of the polygon, and Bending constraints to keep the angle between two adjacent triangles.",
        "implementation": "Implementation",
        "implementation_content1": "Embedding Cloth simulation into the game was quite challenging. First, I wanted the cloth to follow the player, so I set an influence variable that determines how much the particle is affected by the simulation, so that the particles that are not affected by simulation follow the player.",
        "implementation_content2": "Another thing I noticed was that the length of the whole model was extended too much in the low frame. Since I gave the frame time as a delta time, the accuracy of the simulation was decreased. So I modified the stretching constraint a bit. Instead of pulling two particles at the same time, the modified constraint will move only one particle. I named it Shape constraint, a constraint that keeps the shape of a cloth.",
        "result": "Result",
        "references": "References"
      }
    }
  }
}